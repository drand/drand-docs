"use strict";(self.webpackChunkdrand_docs=self.webpackChunkdrand_docs||[]).push([[5706],{1622:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var r=i(4848),t=i(8453);const o={id:"2-3-concepts-specification",title:"2.3 Specification",description:"Outlines the drand protocol specification."},s="2.3 Concepts: Specification",a={id:"concepts/2-3-concepts-specification",title:"2.3 Specification",description:"Outlines the drand protocol specification.",source:"@site/docs/02_concepts/02-03-Concepts_Specification.md",sourceDirName:"02_concepts",slug:"/concepts/2-3-concepts-specification",permalink:"/drand-docs/docs/concepts/2-3-concepts-specification",draft:!1,unlisted:!1,editUrl:"https://github.com/kentbull/drand-docs/tree/main/docs/02_concepts/02-03-Concepts_Specification.md",tags:[],version:"current",frontMatter:{id:"2-3-concepts-specification",title:"2.3 Specification",description:"Outlines the drand protocol specification."},sidebar:"docsSidebar",previous:{title:"2.2 Security Model",permalink:"/drand-docs/docs/concepts/2-2-concepts-security-model"},next:{title:"2.4 Timelock Encryption",permalink:"/drand-docs/docs/concepts/2-4-concepts-timelock-encryption"}},d={},c=[{value:"\ud83d\udcd5 Key Terminology",id:"-key-terminology",level:2},{value:"Metadata",id:"metadata",level:2},{value:"Scheme",id:"scheme",level:2},{value:"Group Configuration",id:"group-configuration",level:2},{value:"Group Configuration Hash",id:"group-configuration-hash",level:2},{value:"Wire Format &amp; API",id:"wire-format--api",level:2},{value:"drand Node Operations",id:"drand-node-operations",level:2},{value:"drand Versioning",id:"drand-versioning",level:3},{value:"drand Modules",id:"drand-modules",level:2},{value:"1. Setup Phase",id:"1-setup-phase",level:3},{value:"2. Randomness Generation Phase",id:"2-randomness-generation-phase",level:3},{value:"Randomness Generation Details",id:"randomness-generation-details",level:2},{value:"Randomness Generation Period",id:"randomness-generation-period",level:3},{value:"Chained vs. Unchained Mode",id:"chained-vs-unchained-mode",level:3},{value:"Root of Trust",id:"root-of-trust",level:2},{value:"Catchup Mode",id:"catchup-mode",level:2},{value:"Syncing",id:"syncing",level:2},{value:"Cryptographic Specification",id:"cryptographic-specification",level:2},{value:"drand Curve",id:"drand-curve",level:3},{value:"Distributed Public Key",id:"distributed-public-key",level:3},{value:"Beacon Signature",id:"beacon-signature",level:3},{value:"Partial Beacon Signature",id:"partial-beacon-signature",level:3},{value:"Distributed Key Generation",id:"distributed-key-generation",level:3},{value:"Resharing",id:"resharing",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"23-concepts-specification",children:"2.3 Concepts: Specification"})}),"\n",(0,r.jsx)(n.p,{children:"This document outlines the specifications of the drand protocols."}),"\n",(0,r.jsx)(n.h2,{id:"-key-terminology",children:"\ud83d\udcd5 Key Terminology"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Drand Node"}),": A server that runs the ",(0,r.jsx)(n.a,{href:"https://github.com/drand/drand/",children:"drand code"}),", participating in the distributed key generation (DKG) process and randomness generation. Each node can run multiple independent internal randomness processes, each with its own randomness generation frequency."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Drand Network"}),": A group of nodes running a specific process, acting as an independent beacon generator."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Drand Beacon"}),": The output created by the drand network, containing the signature of the previous beacon, the round of the beacon, and the signature itself."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Beacon ID"}),": A unique identifier for each beacon process running on a drand node. This ID helps each drand node dispatch received messages to the correct internal process."]}),"\n",(0,r.jsx)(n.h2,{id:"metadata",children:"Metadata"}),"\n",(0,r.jsxs)(n.p,{children:["Each request sent by a drand node includes metadata to communicate important message-related data. The ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Protocol_Buffers",children:"protobuf"})," definition for this field is:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"message Metadata {\n  NodeVersion node_version = 1;\n  string beaconID = 2;\n  bytes chain_hash = 3;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"scheme",children:"Scheme"}),"\n",(0,r.jsx)(n.p,{children:"A scheme is a network-level configuration set by a coordinator when starting a new network. Available schemes are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DefaultSchemeID"}),': "pedersen-bls-chained"']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"UnchainedSchemeID"}),': "pedersen-bls-unchained"']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ShortSigSchemeID"}),': "bls-unchained-on-g1"']}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"group-configuration",children:"Group Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Group Configuration includes all necessary information about a running drand network, such as nodes, threshold, period, ID, scheme, genesis time, genesis seed, distributed public key, and transition time. This configuration is shared internally within drand nodes."}),"\n",(0,r.jsx)(n.h2,{id:"group-configuration-hash",children:"Group Configuration Hash"}),"\n",(0,r.jsxs)(n.p,{children:["The group configuration is uniquely referenced via its canonical hash, derived using the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/BLAKE_(hash_function)",children:"BLAKE2b"})," hash function."]}),"\n",(0,r.jsx)(n.h2,{id:"wire-format--api",children:"Wire Format & API"}),"\n",(0,r.jsxs)(n.p,{children:["Drand uses ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/GRPC",children:"gRPC"})," as the networking protocol. All exposed services and protobuf definitions are in the ",(0,r.jsx)(n.code,{children:"protocol.proto"})," file for intra-node protocols and in the ",(0,r.jsx)(n.code,{children:"api.proto"})," file."]}),"\n",(0,r.jsx)(n.h2,{id:"drand-node-operations",children:"drand Node Operations"}),"\n",(0,r.jsx)(n.p,{children:"Generating public randomness is the primary function of drand. Each node can run multiple processes, each independent of the others, identified and dispatched using the Beacon ID."}),"\n",(0,r.jsx)(n.h3,{id:"drand-versioning",children:"drand Versioning"}),"\n",(0,r.jsx)(n.p,{children:"Each request sent by a drand node contains the protocol version used. Drand uses semantic versioning, allowing only nodes with the same MAJOR version to communicate."}),"\n",(0,r.jsx)(n.h2,{id:"drand-modules",children:"drand Modules"}),"\n",(0,r.jsx)(n.p,{children:"drand operates in two phases: 1. setup and 2. generation."}),"\n",(0,r.jsx)(n.h3,{id:"1-setup-phase",children:"1. Setup Phase"}),"\n",(0,r.jsx)(n.p,{children:"During the setup phase, nodes perform a DKG protocol to create the collective public key and individual private key shares. This setup uses a coordinator to collect public keys and create the group configuration."}),"\n",(0,r.jsx)(n.h3,{id:"2-randomness-generation-phase",children:"2. Randomness Generation Phase"}),"\n",(0,r.jsx)(n.p,{children:"After setup, nodes switch to randomness generation mode, broadcasting partial signatures periodically. Once enough partial signatures are gathered, a final signature is reconstructed, verified, and hashed to produce the public randomness."}),"\n",(0,r.jsx)(n.h2,{id:"randomness-generation-details",children:"Randomness Generation Details"}),"\n",(0,r.jsx)(n.h3,{id:"randomness-generation-period",children:"Randomness Generation Period"}),"\n",(0,r.jsx)(n.p,{children:'The drand network outputs a new random beacon every period, mapping a beacon "round" to a specific time. The function to determine the current round and time is as follows:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func CurrentRound(now, genesis int64, period uint32) (round uint64, time int64) {\n  if now < genesis {\n    return 0\n  }\n  fromGenesis := now - genesis\n  round = uint64(math.Floor(float64(fromGenesis)/period)) + 1\n  time = genesis + int64(nextRound*uint64(period.Seconds()))\n  return\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"chained-vs-unchained-mode",children:"Chained vs. Unchained Mode"}),"\n",(0,r.jsx)(n.p,{children:"drand can operate in two modes regarding randomness generation: chained or unchained. In chained mode, each beacon builds on the previous one, forming a randomness chain. In unchained mode, each beacon is independent."}),"\n",(0,r.jsx)(n.h2,{id:"root-of-trust",children:"Root of Trust"}),"\n",(0,r.jsxs)(n.p,{children:["drand uniquely identifies a randomness chain via the ",(0,r.jsx)(n.code,{children:"Info"})," structure, which includes public key, ID, period, scheme, genesis time, and group hash."]}),"\n",(0,r.jsx)(n.h2,{id:"catchup-mode",children:"Catchup Mode"}),"\n",(0,r.jsx)(n.p,{children:"Nodes must synchronize with each other to catch up if the network stalls. Nodes enter catchup mode if they detect a discrepancy in the expected round, synchronizing beacons until the current round is reached."}),"\n",(0,r.jsx)(n.h2,{id:"syncing",children:"Syncing"}),"\n",(0,r.jsx)(n.p,{children:"Nodes that are offline or restarted should sync with the network, requesting beacons from the last saved round to the current round."}),"\n",(0,r.jsx)(n.h2,{id:"cryptographic-specification",children:"Cryptographic Specification"}),"\n",(0,r.jsx)(n.h3,{id:"drand-curve",children:"drand Curve"}),"\n",(0,r.jsxs)(n.p,{children:["drand uses the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/BLS_digital_signature#BLS12-381",children:"BLS12-381"})," pairing curve, with points sent in compressed form. The hash-to-curve algorithm follows ",(0,r.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/rfc9380/",children:"RFC-9380"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"distributed-public-key",children:"Distributed Public Key"}),"\n",(0,r.jsx)(n.p,{children:"The distributed public key is a list of BLS12-381 G1 points, representing the public polynomial created during the DKG protocol."}),"\n",(0,r.jsx)(n.h3,{id:"beacon-signature",children:"Beacon Signature"}),"\n",(0,r.jsx)(n.p,{children:"A beacon signature is a BLS signature over the message, verified using the distributed public key."}),"\n",(0,r.jsx)(n.h3,{id:"partial-beacon-signature",children:"Partial Beacon Signature"}),"\n",(0,r.jsx)(n.p,{children:"A partial beacon signature is created over the same input as the beacon signature, prefixed with the node's index."}),"\n",(0,r.jsx)(n.h3,{id:"distributed-key-generation",children:"Distributed Key Generation"}),"\n",(0,r.jsx)(n.p,{children:"drand implements the Joint Feldman protocol for DKG, ensuring secure and distributed key generation."}),"\n",(0,r.jsx)(n.h3,{id:"resharing",children:"Resharing"}),"\n",(0,r.jsx)(n.p,{children:"Resharing allows an established group to distribute new shares to a new group of nodes, maintaining the same public key for verifying random beacons."}),"\n",(0,r.jsx)(n.hr,{})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var r=i(6540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);