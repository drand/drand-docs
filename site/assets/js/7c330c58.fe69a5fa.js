"use strict";(self.webpackChunkdrand_docs=self.webpackChunkdrand_docs||[]).push([[2339],{1008:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var n=s(4848),i=s(8453);const r={id:"4-4-ops-guide-metrics-guide",title:"4.4 Metrics Guide",description:"Describes Prometheus instrumentation exposed by drand nodes."},d="4.4 DevOps: Metrics Guide",o={id:"ops-guide/4-4-ops-guide-metrics-guide",title:"4.4 Metrics Guide",description:"Describes Prometheus instrumentation exposed by drand nodes.",source:"@site/docs/04_ops-guide/04-04-DevOps_Metrics_Guide.md",sourceDirName:"04_ops-guide",slug:"/ops-guide/4-4-ops-guide-metrics-guide",permalink:"/docs/ops-guide/4-4-ops-guide-metrics-guide",draft:!1,unlisted:!1,editUrl:"https://github.com/drand/drand-docs/tree/master/docs/04_ops-guide/04-04-DevOps_Metrics_Guide.md",tags:[],version:"current",frontMatter:{id:"4-4-ops-guide-metrics-guide",title:"4.4 Metrics Guide",description:"Describes Prometheus instrumentation exposed by drand nodes."},sidebar:"docsSidebar",previous:{title:"4.3 Storage Backends",permalink:"/docs/ops-guide/4-3-ops-guide-storage-backends"},next:{title:"4.5 Command-line Tools",permalink:"/docs/ops-guide/4-5-ops-guide-command-line-tools"}},c={},a=[{value:"<strong>Local Metrics</strong>",id:"local-metrics",level:2},{value:"<strong>Shared Group Metrics</strong>",id:"shared-group-metrics",level:2},{value:"<strong>Client Metrics</strong>",id:"client-metrics",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"44-devops-metrics-guide",children:"4.4 DevOps: Metrics Guide"})}),"\n",(0,n.jsxs)(t.p,{children:["Drand uses\xa0",(0,n.jsx)(t.a,{href:"https://prometheus.io/",children:"Prometheus"}),"\xa0instrumentation for helping operators monitor and understand the runtime behavior of system."]}),"\n",(0,n.jsx)(t.h2,{id:"local-metrics",children:(0,n.jsx)(t.strong,{children:"Local Metrics"})}),"\n",(0,n.jsxs)(t.p,{children:["The local drand node exposes metrics on an HTTP server listening as specified by the\xa0",(0,n.jsx)(t.code,{children:"--metrics"}),"\xa0command line flag. You can view the reported metrics in a browser at\xa0",(0,n.jsx)(t.code,{children:"http://localhost:<metrics port>/metrics"}),". This page includes"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The default Golang process metrics collected by Prometheus"}),"\n",(0,n.jsx)(t.li,{children:"Statistics on the drand beacon and group behavior"}),"\n",(0,n.jsx)(t.li,{children:"Statistics on the HTTP public listener request load if enabled."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"shared-group-metrics",children:(0,n.jsx)(t.strong,{children:"Shared Group Metrics"})}),"\n",(0,n.jsxs)(t.p,{children:["In addition to the metrics collected within the local node, the drand GRPC group protocol supports re-export and sharing of group metrics between group members. When a local metrics port is specified, metrics shared by other group members can be accessed at\xa0",(0,n.jsx)(t.code,{children:"http://localhost:<metrics port>/peer/<peer address>/metrics"}),". This will only include the drand beacon statistics shared by the remote peer, and does not include the process or internal health of the node. It is meant to allow better visibility when debugging network issues, and helping operators understand where problems originate."]}),"\n",(0,n.jsx)(t.h2,{id:"client-metrics",children:(0,n.jsx)(t.strong,{children:"Client Metrics"})}),"\n",(0,n.jsx)(t.p,{children:"The drand client is capable of collecting metrics on the health of the sources of randomness that it is connected to."}),"\n",(0,n.jsx)(t.p,{children:'For each HTTP endpoint, every 10 seconds, the client sends "heartbeat" requests for the "current" randomness, wherein the requested "current" randomness round is calculated based on the current time and the genesis time of the drand network. The outcomes of these requests are used to generate the following metrics:'}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Heartbeat latency"}),": This is the duration, in milliseconds, between the time when the randomness response was received and the time when it was meant to be produced by the drand nodes (based on the genesis time of the network and the round number). The corresponding Prometheus metric is the gauge\xa0",(0,n.jsx)(t.code,{children:"client_http_heartbeat_latency"}),". In normal conditions, when the network latency is sub-second, one expects the heartbeat latency to be roughly evenly distributed between 0 and 30 seconds. This is caused by the fact that there are multiple heartbeats during a single round, which lasts 30 seconds, as well as the fact that each request blocks until the randomness becomes available. This metric is implemented in [",(0,n.jsx)(t.a,{href:"https://github.com/drand/drand/blob/master/client/http/metric.go#L59",children:"https://github.com/drand/drand/blob/master/client/http/metric.go#L59"}),"]."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Heartbeat success and failure"}),': These are two counters, "success" and "failure", whose Prometheus names are\xa0',(0,n.jsx)(t.code,{children:"client_http_heartbeat_success"}),"\xa0and\xa0",(0,n.jsx)(t.code,{children:"client_http_heartbeat_latency"}),". The success counter is increments after an HTTP request returns a successful response HTTP, otherwise the the failure counter is incremented. This metric is implemented in [",(0,n.jsx)(t.a,{href:"https://github.com/drand/drand/blob/master/client/http/metric.go#L50",children:"https://github.com/drand/drand/blob/master/client/http/metric.go#L50"}),"]."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"In addition, the client maintains a metric on its watch channel for randomness. This channel pushes latest randomness to the client as soon as it is available. The channel is implemented either by connecting to a gossip relay or by polling HTTP endpoints, if a relay is not specified. The relevant metric is:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Watch latency"}),": This is a Prometheus gauge measuring the duration between when a randomness round was received by the client and the time when it was produced by the drand nodes (as calculated based on round number and genesis time). The metric is implemented in [",(0,n.jsx)(t.a,{href:"https://github.com/drand/drand/blob/master/client/metric.go#L37",children:"https://github.com/drand/drand/blob/master/client/metric.go#L37"}),"]."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"All of the above measurements have two significant labels:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The label\xa0",(0,n.jsx)(t.code,{children:"http_address"}),"\xa0identifies the HTTP endpoint that is being queried by the client,"]}),"\n",(0,n.jsxs)(t.li,{children:["The label\xa0",(0,n.jsx)(t.code,{children:"client_id"}),"\xa0identifies the client itself."]}),"\n"]}),"\n",(0,n.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>d,x:()=>o});var n=s(6540);const i={},r=n.createContext(i);function d(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);