"use strict";(self.webpackChunkdrand_docs=self.webpackChunkdrand_docs||[]).push([[1748],{1223:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var r=t(4848),s=t(8453);const a={slug:"drand-on-filecoin-virtual-machine-FVM-draffle",title:"drand on Filecoin Virtual Machine (FVM) - draffle",authors:["yolan"],tags:["FVM","features","how-to"],date:new Date("2023-03-15T00:00:00.000Z")},o=void 0,i={permalink:"/blog/drand-on-filecoin-virtual-machine-FVM-draffle",editUrl:"https://github.com/drand/drand-docs/tree/master/blog/2023-03-15-drand-on-filecoin-virtual-machine-fvm-draffle.mdx",source:"@site/blog/2023-03-15-drand-on-filecoin-virtual-machine-fvm-draffle.mdx",title:"drand on Filecoin Virtual Machine (FVM) - draffle",description:"To mark the launch of user-programmable smart contracts on the Filecoin Virtual Machine (FVM), the drand team is excited to release a three-part blog series on using randomness on the FVM! In this first part, we dive into the prevrandao EVM opcode (the FVM fully supports EVM bytecode!), a sample Solidity contract using it, a UI to interact with it, and some other necessary plumbing to make it all work.",date:"2023-03-15T00:00:00.000Z",tags:[{inline:!1,label:"FVM",permalink:"/blog/tags/fvm",description:"fvm tag"},{inline:!1,label:"Features",permalink:"/blog/tags/features",description:"begginer tag"},{inline:!1,label:"How-to",permalink:"/blog/tags/how-to",description:"how to tag"}],readingTime:7.846666666666667,hasTruncateMarker:!0,authors:[{name:"Yolan Romailler",title:"Co-Founder & Cryptographer",description:"Applied cryptographer with a leaning for broader security/vulnerability research. \n\nWorked on the Distributed Randomness project, drand, at Protocol Labs and also on CBDC and SSI at SICPA, as well as broader cryptographic engineering at Kudelski Security. I've also been a Security Engineer on the Diem security team for Novi (Facebook/Meta).\nA subject matter expert in secure coding. As a consultant, I've supported customers by answering complex questions on security critical systems such as blockchain technologies, and by designing, evaluating and implementing complex cryptography such as key management systems or cryptographic primitives.\n",url:"https://romailler.ch/",page:{permalink:"/blog/authors/yolan"},socials:{linkedin:"https://www.linkedin.com/in/anomalroil/",github:"https://github.com/AnomalRoil",blog:"https://romailler.ch/"},imageURL:"/img/author/yolan.jpeg",key:"yolan"}],frontMatter:{slug:"drand-on-filecoin-virtual-machine-FVM-draffle",title:"drand on Filecoin Virtual Machine (FVM) - draffle",authors:["yolan"],tags:["FVM","features","how-to"],date:"2023-03-15T00:00:00.000Z"},unlisted:!1,prevItem:{title:"Timelock Encryption is now supported on drand mainnet",permalink:"/blog/timelock-encryption-is-now-supported-on-drand-mainnet"},nextItem:{title:"Automata Network Joins the League of Entropy!",permalink:"/blog/auttomata-network-joins-the-league-of-entropy"}},l={authorsImageUrls:[void 0]},d=[{value:"\ud83c\udfb2 <strong>Randomness on the Blockchain</strong> \u26d3\ufe0f",id:"-randomness-on-the-blockchain-\ufe0f",level:2},{value:"<strong>How Ethereum Increases Fairness</strong>",id:"how-ethereum-increases-fairness",level:3},{value:"<strong>How RANDAO Works</strong>",id:"how-randao-works",level:3},{value:"<strong>Advantages Over Single-Author Randomness</strong>",id:"advantages-over-single-author-randomness",level:3},{value:"\u26d4 <strong>Challenges and Limitations</strong>",id:"-challenges-and-limitations",level:3},{value:"<strong>Illustrating Last Mover&#39;s Advantage</strong>",id:"illustrating-last-movers-advantage",level:3},{value:"<strong>RANDAO on FVM</strong>",id:"randao-on-fvm",level:3},{value:"<strong>Refresher of how drand works</strong>",id:"refresher-of-how-drand-works",level:3},{value:"<strong>Key Features of drand</strong>",id:"key-features-of-drand",level:3},{value:"<strong>drand in Filecoin</strong>",id:"drand-in-filecoin",level:3},{value:"The UI",id:"the-ui",level:2},{value:"The Contract",id:"the-contract",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"To mark the launch of user-programmable smart contracts on the Filecoin Virtual Machine (FVM), the drand team is excited to release a three-part blog series on using randomness on the FVM! In this first part, we dive into the prevrandao EVM opcode (the FVM fully supports EVM bytecode!), a sample Solidity contract using it, a UI to interact with it, and some other necessary plumbing to make it all work."}),"\n","\n",(0,r.jsxs)(n.p,{children:["If you want to skip all the wonderful learning, you can jump straight into the demo project we developed ",(0,r.jsx)(n.a,{href:"https://github.com/drand/draffle",children:(0,r.jsx)(n.strong,{children:"on GitHub"})})," - the contract is deployed at address ",(0,r.jsx)(n.code,{children:"0x9D38f3BB80D98cE09C3f0936Bea140181d4CCABA"})," on the Hyperspace testnet! A little familiarity with ",(0,r.jsx)(n.a,{href:"https://soliditylang.org/",children:(0,r.jsx)(n.strong,{children:"Solidity"})})," will be helpful to follow along, but anyone familiar with a C-style language should be able to get the gist."]}),"\n",(0,r.jsxs)(n.h2,{id:"-randomness-on-the-blockchain-\ufe0f",children:["\ud83c\udfb2 ",(0,r.jsx)(n.strong,{children:"Randomness on the Blockchain"})," \u26d3\ufe0f"]}),"\n",(0,r.jsxs)(n.p,{children:["When developers think of randomness, we most often think of private randomness - for example, ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator",children:(0,r.jsx)(n.strong,{children:"using a cryptographically secure pseudorandom number generator"})})," such as ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki//dev/random",children:(0,r.jsx)(n.strong,{children:"/dev/random/"})})," to generate a private key. When executing a smart contract in a blockchain ecosystem, this poses a few challenges: Who provides the randomness? How do you know it's random? If you interact with a smart contract, you can't trust the author to generate randomness for you, as they may have a vested interest in the outcome. Similarly, you can't trust miners to generate the randomness for you, as they too might have an interest in the outcome (or wish to collude with other participants)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["To be more concrete: ",(0,r.jsx)(n.strong,{children:"Suppose I'm running a raffle via a smart contract"}),", and users enter the draw by calling a function such as the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"address[] entrants;\n\nfunction enter() external {\n    entrants.push(msg.sender);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:['Everybody who submits a transaction (and has it mined) has their address added to the list of entrants, which will be "randomly" drawn from. As the ',(0,r.jsx)(n.em,{children:"totally unbiased"})," author of the smart contract, I've provided another function that allows me to draw the randomly chosen participant:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'event Winner(address theWinner);\n\nfunction draw(uint32 someTotallyRandomNumber) external {\n    require(author == msg.sender, "Only the completely unbiased author can execute the draw winner!"); // assuming we have set the `author` field in the constructor somewhere\n    emit Winner(entrants[someTotallyRandomNumber]);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Of course, in blockchain-land, the state of the contract is public to everyone, and you as the author could simply register your own address as an entrant and pass in its index to win the raffle yourself!"}),"\n",(0,r.jsx)(n.h3,{id:"how-ethereum-increases-fairness",children:(0,r.jsx)(n.strong,{children:"How Ethereum Increases Fairness"})}),"\n",(0,r.jsxs)(n.p,{children:["To address the challenges of randomness in smart contracts, the Ethereum community created ",(0,r.jsx)(n.a,{href:"https://github.com/randao/randao",children:(0,r.jsx)(n.strong,{children:"RANDAO"})}),", a Decentralized Autonomous Organization (DAO) for providing randomness."]}),"\n",(0,r.jsx)(n.h3,{id:"how-randao-works",children:(0,r.jsx)(n.strong,{children:"How RANDAO Works"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Contribution Phase"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In each block, 128 addresses from the network can contribute their piece of randomness."}),"\n",(0,r.jsx)(n.li,{children:"Contributors send a small amount of ETH to the RANDAO contract along with a hash of their chosen random number."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reveal Phase"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Six blocks later, contributors reveal their number."}),"\n",(0,r.jsx)(n.li,{children:"Revealing the number earns them an ETH bounty."}),"\n",(0,r.jsx)(n.li,{children:"Failing to reveal the number results in the loss of their deposited ETH."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Aggregation Phase"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Revealed numbers are combined to create a final random number."}),"\n",(0,r.jsx)(n.li,{children:"This final random number is included in the block and is available to smart contracts in the next block using the prevrandao opcode."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"advantages-over-single-author-randomness",children:(0,r.jsx)(n.strong,{children:"Advantages Over Single-Author Randomness"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verifiability"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Users can inspect the RANDAO contract state and see all the inputs combined to create the final random number."}),"\n",(0,r.jsx)(n.li,{children:"This transparency attests to the method of construction and ensures fairness."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced Bias"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Instead of relying on a single ",(0,r.jsx)(n.em,{children:"totally unbiased"})," author, up to 128 parties are involved in creating the randomness."]}),"\n",(0,r.jsx)(n.li,{children:"This makes it much harder to influence the output, raising the bar for any potential bias."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"-challenges-and-limitations",children:["\u26d4 ",(0,r.jsx)(n.strong,{children:"Challenges and Limitations"})]}),"\n",(0,r.jsx)(n.p,{children:"While RANDAO improves fairness, it is not entirely immune to manipulation. One such challenge is the 'last mover's advantage':"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Commit/Reveal Scheme"}),": Participants commit to a random number ahead of time by providing the corresponding (SHA-3) hash. Later, they can choose to reveal or not reveal that number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Last Mover's Advantage"}),": The last participant to reveal their number can choose to reveal or not reveal it based on the desired outcome, thereby biasing the final output."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"illustrating-last-movers-advantage",children:(0,r.jsx)(n.strong,{children:"Illustrating Last Mover's Advantage"})}),"\n",(0,r.jsx)(n.p,{children:"Imagine a scenario with 10 slots where each participant decides a single bit of the output number:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Number | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | ? |\nSlot   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Suppose the committed number is ",(0,r.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"The last participant can influence the final bit by deciding whether to reveal or not reveal their number."}),"\n",(0,r.jsx)(n.li,{children:"For example, if a coin-flipping smart contract uses the last bit to determine heads (1) or tails (0), the last participant can ensure a desired outcome by revealing or not revealing their number."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In practice, the influence is probabilistic and not direct. However, larger players who can fill more of the 'slots' in RANDAO can still exert undue influence."}),"\n",(0,r.jsx)(n.p,{children:"By involving multiple parties and ensuring transparency, RANDAO significantly enhances the fairness and reliability of randomness in smart contracts, despite its limitations."}),"\n",(0,r.jsx)(n.h3,{id:"randao-on-fvm",children:(0,r.jsx)(n.strong,{children:"RANDAO on FVM"})}),"\n",(0,r.jsxs)(n.p,{children:["RANDAO on EVM is still great - the above is more an insight into some of the security assumptions around it, as a way of introducing FVM's approach to RANDAO and contrasting it. As the FVM is EVM compatible (i.e., everything possible in EVM bytecode is also possible on the FVM), it must also provide a ",(0,r.jsx)(n.code,{children:"prev_randao"})," opcode for use in smart contracts and compatibility purposes. Instead of bridging to Ethereum or running its own RANDAO (both of which could happen in the future), Filecoin already has its own source of randomness used for leader election: drand."]}),"\n",(0,r.jsx)(n.h3,{id:"refresher-of-how-drand-works",children:(0,r.jsx)(n.strong,{children:"Refresher of how drand works"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Threshold Network"}),": drand is a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Threshold_cryptosystem",children:(0,r.jsx)(n.strong,{children:"threshold network"})})," that provides publicly verifiable, unbiasable randomness. It exploits the fact that the hash of a signature is indistinguishable from randomness to people without the associated private key."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cooperative Action"}),": A threshold network is a network of nodes that can cooperatively perform actions such as signing. Enough nodes need to work together (referred to as the 'threshold') to perform these actions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shamir's Secret Sharing"}),": Using a form of ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing",children:(0,r.jsx)(n.strong,{children:"Shamir's Secret Sharing"})}),", the network creates a cryptographic keypair that no single member of the group has the private key of. Instead, they each get a share of that private key and must aggregate a threshold number of signatures to create a full signature on behalf of the entire group."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-drand",children:(0,r.jsx)(n.strong,{children:"Key Features of drand"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unbiasable Randomness"}),": Unlike RANDAO, nodes in drand cannot influence the final random output. Once the keypair is generated, all future random numbers are deterministically decided, but nobody can get them until they've received a threshold number of signatures for each number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security Considerations"}),": One drawback is that if a threshold number of nodes were compromised, all future random numbers could be derived."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"drand-in-filecoin",children:(0,r.jsx)(n.strong,{children:"drand in Filecoin"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inclusion in Blocks"}),": In Filecoin, the drand randomness beacon for the current time is included in every block's headers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Usage in Smart Contracts"}),": When a contract calls the ",(0,r.jsx)(n.code,{children:"prevrandao"})," opcode, the randomness from the previous block is provided to it. This offers a straightforward method of using randomness on-chain, though with some potential pitfalls to consider."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Okay - without further ado let's jump into the web app and code!"}),"\n",(0,r.jsx)(n.h2,{id:"the-ui",children:"The UI"}),"\n",(0,r.jsx)(n.p,{children:"When the user first opens the UI, they should see something like this:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"https://drand.love/assets/img/start.bdca1319.png",src:t(1419).A+"",width:"2048",height:"1042"})}),"\n",(0,r.jsx)(n.p,{children:"On the left-hand side we see when the next draw is scheduled, the current block and any draws that have already happened. There\u2019s also a button labelled \u2018Enter the next draw\u2019 that we can click to pay the entry fee via our Metamask wallet. When we click it, a popup from Metamask such as the following appears:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"https://drand.love/assets/img/connect-wallet.083095e5.png",src:t(7342).A+"",width:"712",height:"1394"})}),"\n",(0,r.jsx)(n.p,{children:"Once we\u2019ve confirmed the transaction, we\u2019ve now entered the draw:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"https://drand.love/assets/img/draw-accepted.2ff1aab6.png",src:t(8382).A+"",width:"2048",height:"1043"})}),"\n",(0,r.jsx)(n.p,{children:"If you\u2019re on hyperspace, we can wait up to 24 hours (the default) until the next draw is scheduled, and we will be able to trigger it (in the next section we\u2019ll find how to reduce that to any time we want for easier testing). At the time of the draw, the right-hand side of the UI will have changed:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"https://drand.love/assets/img/trigger-draw.4356efc5.png",src:t(5069).A+"",width:"2048",height:"1049"})}),"\n",(0,r.jsx)(n.p,{children:"At the draw block height, users will be able to compete to trigger the draw and receive a small payout. Once the draw has been triggered, a new one is scheduled:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"https://drand.love/assets/img/draw-triggered.ac101ff4.png",src:t(6397).A+"",width:"2048",height:"1049"})}),"\n",(0,r.jsx)(n.h2,{id:"the-contract",children:"The Contract"}),"\n",(0,r.jsxs)(n.p,{children:["First off, in the ",(0,r.jsx)(n.code,{children:"./contracts/"})," directory, we have a single file called ",(0,r.jsx)(n.a,{href:"https://drand.love/blog/2023/03/16/draffle/contracts/DRaffle.sol",children:(0,r.jsx)(n.strong,{children:"DRaffle.sol"})}),". It contains the solidity code which will be run on FVM to manage all the entrants and payouts from the contest. Let's take a look at its constructor and fields:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"solidityCopy code\nuint256 costPerDraw;\nuint256 drawCutoff;\nuint256 triggerReward;\nuint256 nextDrawBlockHeight;\n\naddress[] candidates;\n\nconstructor(uint256 roundCutoff, uint256 cost, uint256 reward) {\n    costPerDraw = cost;\n    triggerReward = reward;\n    drawCutoff = roundCutoff;\n\n    scheduleNext();\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The first field set in the constructor enables the author of the contract to choose a ",(0,r.jsx)(n.code,{children:"cost"})," of entry (in FIL). All entrants will pay it, and (nearly all of) the total pool for every draw will be paid out to the winning address."]}),"\n",(0,r.jsxs)(n.li,{children:["The second field set is a ",(0,r.jsx)(n.code,{children:"reward"})," for users who initiate the draw. As the contract runs on-chain, we can't easily (in solidity anyway) schedule future draws automagically - we have to rely on somebody in the ecosystem submitting a transaction to trigger the draw. To incentivise that, we'll provide a small FIL bounty to cover the transaction fee plus a little extra, so users will want to trigger the draw."]}),"\n",(0,r.jsxs)(n.li,{children:["The final field set - ",(0,r.jsx)(n.code,{children:"drawCutOff"})," - is the number of blocks in advance we wish to close entries for a given draw. Readers with a keen eye will have noticed in the explanation of the ",(0,r.jsx)(n.code,{children:"prevrandao"})," instruction, that it returns the randomness from the ",(0,r.jsx)(n.em,{children:"previous"})," block header, and not the current block. Entrants could therefore know the random number used for a draw in advance of the draw happening.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.em,{children:"In follow-up blog posts, we'll discuss how we can use more current randomness to avoid this pitfall, but for now let's close draws a few blocks in advance to eliminate this possibility of gaming the draw."})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Finally the constructor calls the ",(0,r.jsx)(n.code,{children:"scheduleNext"})," function which will set the ",(0,r.jsx)(n.code,{children:"nextDrawBlockHeight"})," field, clear any candidates and emit some convenient events for the UI to consume. It's implementation is as follows:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"solidityCopy code\nfunction scheduleNext() internal {\n    candidates = new address ;\n    nextDrawBlockHeight = block.number + 2880;\n    emit Scheduled(nextDrawBlockHeight);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"With this implementation a draw will happen once every 24 hours (Filecoin mines a block every 30 seconds, i.e. 2 per minute, 60 minutes per hour, 24 hours per day- 2 * 60 * 24 = 2880), but it can easily be configured to be more frequent."}),"\n",(0,r.jsx)(n.p,{children:"Now to our function users will call to enter the draw:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'solidityCopy code\nfunction enter() external payable {\n    require(msg.value == costPerDraw, "you have passed too much or too little money to enter the lotto");\n    require(block.number < nextDrawBlockHeight - drawCutoff, "It\'s too close to the next draw to participate");\n    candidates.push(msg.sender);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["It's quite simple: users must pass a token amount equal to the ",(0,r.jsx)(n.code,{children:"costPerDraw"})," into the contract with their transaction (hence the ",(0,r.jsx)(n.code,{children:"payable"})," keyword). If they correctly do that and it's not too close to the draw (remembering our ",(0,r.jsx)(n.code,{children:"prevrandao"})," limitation discussed above!), their address is added to the candidate list for the draw."]}),"\n",(0,r.jsx)(n.p,{children:"The final important function is the draw function itself:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"solidityCopy code\nfunction draw() external payable {\n    // first we ensure that users can't trigger the draw too early\n    // we let them draw late, because perhaps nobody could get a transaction mined for the exact block height!\n    require(block.number >= nextDrawBlockHeight, \"it's too early to trigger the draw!\");\n\n    // if nobody entered the draw, and thus there is no money to pay out, we send an event that there was no winner and\n    // just schedule the next draw\n    uint numberOfEntries = candidates.length;\n    if (numberOfEntries == 0) {\n        emit NoWinner(block.number);\n\n    // if there are candidates for the draw, we use the `prevrandao` value from the block, and turn it into an index to choose the winner.\n    // note: using the modulo operation can result in an output bias - check this great blog post on the matter: <https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/>\n    } else {\n        address winner = candidates[block.prevrandao % numberOfEntries];\n        uint256 amount = numberOfEntries * costPerDraw - triggerReward;\n\n        // we pay out the chosen winner\n        payable(winner).transfer(amount);\n\n        // and also pay out the `triggerReward` to the address who triggered the draw successfully\n        // a small point to note is that they won't get paid out if there are no entrants...\n        // paying them out would require the contract to maintain its own balance of tokens to pay out\n        // raffles with no entries, so it's been omitted for convenience, but it's something to consider if you\n        // decide to run your own raffle!\n        payable(msg.sender).transfer(triggerReward);\n\n        // and emit an event to let any listeners know who won!\n        emit Winner(block.number, winner, amount);\n    }\n\n    // finally, regardless of whether there is a winner or not we want to schedule the next draw as we saw in the constructor\n    scheduleNext();\n}\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So that's it for part 1 - how to run a raffle using drand on the FVM via solidity. The sample repository contains a lot more useful tooling for deploying your own smart contract to the ",(0,r.jsx)(n.a,{href:"https://hyperspace.yoga/",children:(0,r.jsx)(n.strong,{children:"Hyperspace testnet"})})," or your own local ",(0,r.jsx)(n.a,{href:"https://trufflesuite.com/ganache/",children:(0,r.jsx)(n.strong,{children:"ganache network"})}),". In our next post, we'll discuss how to use more immediate randomness functionality specific to the FVM, stepping outside the bounds of EVM compatibility."]}),"\n",(0,r.jsxs)(n.p,{children:["Until then you can find the team on both the ",(0,r.jsx)(n.a,{href:"https://filecoin.io/slack",children:(0,r.jsx)(n.strong,{children:"Filecoin slack"})})," and our own ",(0,r.jsx)(n.a,{href:"https://join.slack.com/t/drandworkspace/shared_invite/zt-19u4rf6if-bf7lxIvF2zYn4~TrBwfkiA",children:(0,r.jsx)(n.strong,{children:"drand slack"})})," should you have any questions. Enjoy deploying cool projects to the FVM, and let us know how you've been using the FVM and randomness!"]}),"\n",(0,r.jsx)(n.hr,{})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},7342:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/connect-wallet.083095e5-f1603df1091b63db423dd7e7245fe794.png"},8382:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/draw-accepted.2ff1aab6-d1598b7ac9596149bffc8764498031e8.png"},6397:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/draw-triggered.ac101ff4-f2804b448884e9c64783c4af3f3a0724.png"},1419:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/start.bdca1319-5b6ec8b47e6a2be361d8b5ebd73a236f.png"},5069:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/trigger-draw.4356efc5-9cf48c8285526c36ea5093aec44344c0.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);